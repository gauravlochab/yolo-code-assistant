# YOLO Code Testing Framework

This directory contains a comprehensive testing framework for validating Python code generated by the YOLO assistant. The framework ensures that generated code is syntactically correct, executes successfully, and follows YOLO best practices.

## üéØ Purpose

The testing framework validates that the YOLO assistant generates:
- **Syntactically correct** Python code
- **Executable code** that runs without errors
- **YOLO-compliant code** that follows best practices
- **Robust code** with proper error handling

## üìÅ Files Overview

### Core Testing Files

- **`test_utils.py`** - Core utility functions for code testing
- **`conftest.py`** - Pytest configuration and shared fixtures
- **`test_code_execution.py`** - Main test suite for code execution validation
- **`test_yolo_code_generation.py`** - YOLO-specific code pattern tests
- **`test_integration.py`** - End-to-end integration tests

### Helper Files

- **`simple_test.py`** - Standalone test script (no pytest required)
- **`run_tests.py`** - Test runner script with different test categories
- **`README.md`** - This documentation file

## üöÄ Quick Start

### Option 1: Simple Test (Recommended)

Run the standalone test script that doesn't require pytest:

```bash
cd tests
uv run python simple_test.py
```

This will run a comprehensive test suite covering all major functionality.

### Option 2: Using Pytest (if available)

If pytest is installed, you can run the full test suite:

```bash
cd tests
python -m pytest -v
```

### Option 3: Using the Test Runner

Use the custom test runner for specific test categories:

```bash
cd tests
python run_tests.py --type unit    # Run unit tests only
python run_tests.py --type fast    # Run fast tests only
python run_tests.py --type all     # Run all tests
```

## üß™ Test Categories

### 1. Syntax Validation Tests
- Validate Python syntax using AST parsing
- Test both valid and invalid code samples
- Extract imports, functions, and code structure

### 2. Code Execution Tests
- Execute code safely in isolated subprocess environments
- Test with comprehensive YOLO mocks
- Handle timeouts and error scenarios
- Validate execution results

### 3. YOLO-Specific Tests
- Validate YOLO import patterns
- Check for proper model creation
- Verify result handling
- Test YOLO best practices

### 4. Code Quality Tests
- Analyze code structure and patterns
- Check for error handling
- Validate documentation and comments
- Assess code complexity

### 5. Integration Tests
- Test complete code generation pipeline
- Validate MCP server integration
- Test real-world YOLO scenarios
- End-to-end workflow validation

## üîß Key Features

### Safe Code Execution
- **Subprocess isolation** - Code runs in separate processes
- **Timeout protection** - Prevents infinite loops
- **Mock dependencies** - YOLO, OpenCV, PyTorch mocks included
- **Error capture** - Detailed error reporting and analysis

### YOLO Mock System
The framework includes comprehensive mocks for:
- **YOLO models** - Mock prediction, training, export functions
- **OpenCV** - Mock image/video processing functions
- **PyTorch** - Mock device and tensor operations
- **File system** - Mock file operations for testing

### Code Quality Analysis
- **Import analysis** - Validate all import statements
- **Function extraction** - Identify and analyze functions
- **Pattern detection** - Find YOLO-specific code patterns
- **Best practice validation** - Check for proper error handling

## üìä Test Results

The framework provides detailed test results including:
- **Syntax validation** - Pass/fail with error details
- **Execution status** - Success/failure with output capture
- **Performance metrics** - Execution time and resource usage
- **Quality scores** - Code structure and pattern analysis

## üõ†Ô∏è Usage Examples

### Testing Generated Code

```python
from test_utils import execute_code_safely, validate_yolo_code_structure

# Test a piece of generated YOLO code
generated_code = """
from ultralytics import YOLO
model = YOLO('yolov8n.pt')
results = model.predict('image.jpg')
print('Detection completed')
"""

# Execute safely with mocks
result = execute_code_safely(generated_code, use_mocks=True)
print(f"Success: {result.success}")
print(f"Output: {result.output}")

# Validate YOLO structure
validation = validate_yolo_code_structure(generated_code)
print(f"Has YOLO import: {validation['has_yolo_import']}")
print(f"Creates model: {validation['creates_model']}")
```

### Custom Test Scenarios

```python
from test_utils import analyze_code_quality

# Analyze code quality
code = "your_generated_code_here"
analysis = analyze_code_quality(code)

print(f"Has imports: {analysis['has_imports']}")
print(f"Has functions: {analysis['has_functions']}")
print(f"Has error handling: {analysis['has_error_handling']}")
print(f"YOLO patterns found: {analysis['yolo_patterns_found']}")
```

## üîç Troubleshooting

### Common Issues

1. **Import Errors**: Make sure you're running from the correct directory
2. **Timeout Issues**: Increase timeout values for complex code
3. **Mock Failures**: Check that mocks are properly configured

### Debug Mode

For debugging test failures, you can:
- Check the `result.error` field for detailed error messages
- Use `result.output` to see actual execution output
- Set longer timeouts for complex operations

## üìà Extending the Framework

### Adding New Tests

1. Create test functions in appropriate test files
2. Use the existing utility functions from `test_utils.py`
3. Follow the established patterns for error handling
4. Add appropriate assertions and validation

### Adding New Mocks

1. Extend the `YOLOMocks` class in `test_utils.py`
2. Add new mock modules to `_prepare_code_with_mocks()`
3. Test the new mocks with sample code

### Custom Validators

1. Add new validation functions to `test_utils.py`
2. Follow the pattern of returning dictionaries with validation results
3. Include both positive and negative test cases

## üéØ Best Practices

1. **Always use mocks** for external dependencies
2. **Set appropriate timeouts** to prevent hanging tests
3. **Validate both syntax and execution** for comprehensive testing
4. **Check YOLO-specific patterns** to ensure proper usage
5. **Test error scenarios** to ensure robust code generation

## üìù Contributing

When adding new tests:
1. Follow the existing code style and patterns
2. Add comprehensive documentation
3. Include both positive and negative test cases
4. Test with various YOLO code scenarios
5. Update this README if adding new features

---

This testing framework ensures that the YOLO assistant generates high-quality, executable Python code that follows best practices and handles errors gracefully.
